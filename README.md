# Автоматизированное тестирование
![Aditya Vikram Singh Banner](https://media.giphy.com/media/26tn33aiTi1jkl6H6/giphy.gif)
API ([wiki](http://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D1%80%D0%
BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%BF%D1%80%D0%B8%D
0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9)) — это набор функций, которые можно вызывать, чтобы
получить какие-то данные. Например, у яндекс-карт есть [АПИ геокодера]
(https://tech.yandex.ru/maps/doc/geocoder/desc/concepts/About-docpage/). Отправив к нему запрос с
географическим адресом, вы можете получить координаты точки (и наоборот), а [у Центробанка есть API](http://www.cbr.ru/scripts/Root.asp?PrtId=DWS)
```
зайти на страницу http://example.com/register
ввести в поле «Email» значение tester@example.com
ввести в поле «Пароль» значение 123456
ввести в поле «Повторите пароль» значение 123456
нажать кнопку «Зарегистрироваться»
дождаться загрузки страницы с таймаутом 5 секунд
убедиться, что на странице выводится текст «Вы зарегистрированы на сайте»
```

 `hello…`

это [PhpUnit](https://phpunit.de/) и [Codeception](https://codeception.com/). Вот пример PhpUnitтестов для описанной выше функции `truncate`:
```php
class TruncateTest extends \PHPUnit\Framework\TestCase
{
 public function testShortStringRemainsAsIs()
 {
 // Act: вызываем функцию
 $result = truncate("hello", 10);
 // Assert: проверяем, что возвращенный результат совпадает с ожидаемым
 $this->assertEquals("hello", $result);
 }
 public function testLongStringIsTruncated()
 {
 $result = truncate("hello world", 5);
 $this->assertEquals("hello…", $result);
 }
}
```
Метод `assertEquals()` из PhpUnit проверяет, что фактический результат совпадает с ожидаемым, и

**Использование assertions и тайп-хинтов**. `assert()` ([мануал]
(http://php.net/manual/ru/function.assert.php)) — это функция, которая выдает ошибку если условие в
скобках не выполняется. Например, если вы написали функцию, и она принимает только числа от 0 до 5,
логично в начале поставить `assert` для проверки этого: 
```php
function doSomething(int $a) 
{
10.02.2022, 20:59 https://gist.githubusercontent.com/codedokode/a455bde7d0748c0a351a/raw/af3c559f823c37ec51924cb90942eb98b2edf2e2/%…
https://gist.githubusercontent.com/codedokode/a455bde7d0748c0a351a/raw/af3c559f823c37ec51924cb90942eb98b2edf2e2/%25D0%25A2%25D0… 5/12
 assert($a >= 0 && $a <= 5);
 ...
```

```php
function doSomeWork(SomeClass $a, string $b): int 
```
**Статический анализ кода**. Специальная программа проверяет исходники, не запуская код, с целью
найти опечатки и неправильные куски кода. Такая программа хорошо ищет ошибки ситаксиса: `$x = ($x +
1;` (пропущена скобка), опечатки вроде `if ($x = 1)` (используется `=` вместо `==` в if), опечатки в
именах переменных, функций и классов, обращение к несуществующей переменной. 
Для PHP есть анализаторы [PhpStan](https://phpstan.org/), [Phan](https://github.com/phan/phan) и
[Psalm](https://psalm.dev/).
**[Fuzz testing](http://en.wikipedia.org/wiki/Fuzz_testing)** :
```xml
<phpunit bootstrap="bootstrap.php">
 <testsuites>
 <testsuite name="count">
 <file>FunctionCountTest.php</file>
 </testsuite>
 </testsuites> 
</phpunit>
```

```php
// Создаем объект-тестировщик
$I = new AcceptanceTester($scenario);
// Задаем название теста (оно отображается в отчете)
$I->wantTo('Test that registration works');
// Переходим на страницу
$I->amOnPage('/register');
// Заполняем форму
$I->fillField('email', 'tester@example.com');
$I->fillField('password', '123456');
$I->fillField('password-confirm', '123456');
// Отправляем нажатием кнопки
$I->click('Register');
// Проверяем результат
$I->see('You have registered');
// Проверяем что запись появилась в БД
$I->seeInDatabase('users', ['email' => 'tester@example.com']);
```
ибки). Этот код запускается под Node.JS:
```js
const Browser = require('zombie');
// В тесте мы будем отправлять запросы на адрес http://example.com/signup
// однако эти запросы будут обслуживаться установленным локально 
// сервером на порту 3000 с адресом localhost:3000
Browser.localhost('example.com', 3000);
// describe описывает сценарий теста, 
// причем блоки describe могут вкладываться друг в друга
describe('Пользователь заходит на страницу регистрации', function() {
 // создаем объект, имитирующий браузер
 const browser = new Browser();
 
 // Действие, выполняемое до теста - переход на нужную страницу
 before(function(done) {
10.02.2022, 20:59 https://gist.githubusercontent.com/codedokode/a455bde7d0748c0a351a/raw/af3c559f823c37ec51924cb90942eb98b2edf2e2/%…
https://gist.githubusercontent.com/codedokode/a455bde7d0748c0a351a/raw/af3c559f823c37ec51924cb90942eb98b2edf2e2/%25D0%25A2%25D0… 9/12
 browser.visit('/signup', done);
 });
 describe('пользователь заполняет и отправляет форму', function() {
 before(function(done) {
 browser
 .fill('email', 'tester@example.com')
 .fill('password', '123456')
 .fill('password-confirm', '123456')
 .pressButton('Зарегистрироваться', done);
 });
 // it описывает конкретное требование и код для его проверки
 it('регистрация должна быть успешной', function() {
 browser.assert.success();
 });
 it('пользователь должен увидеть приветственное сообщение', function() {
 // Уведомление должно вывестись в элементе с классом notification 
 // (используется CSS-синтаксис селекторов)
 browser.assert.text('.notification', 'Вы успешно зарегистрированы');
 });
 });
});
```
### Jasmine
[Jasmine](http://jasmine.github.io/) (англ.) - это тоже фреймворк для тестирования JS-кода с уклоном
в BDD (Behaviour-Driven Development). Если вы забыл, то идея BDD в том, что мы до разработки
описываем требования (спецификацию) к коду в виде тестов. Он позволяет писать простые, легко читаемые
тесты. Запускать тесты можно как через браузер (если вы хочете смотреть релуьтаты глазами), так и из
командной строки с помощью Node.JS (если проверку надо автоматизировать). Если твои тесты используют
взаимодействие с DOM (или какие-то другие компоненты браузера) то для запуска под Node.JS придется
подключить упомянутый выше JSDOM. Вот пример простого теста на Jasmine, которым мы протестируем
функцию вычисления квадратного корня `Math.sqrt()`:
```js
describe("Math.sqtr() это функция", function() {
 it("вычисляет квадратный корень", function() {
 expect(Math.sqrt(9)).toBe(3);
 });
 
 it("возвращает нуль, если попытаться найти корень из нуля", function () {
 expect(Math.sqrt(0)).toBe(0);
 });
 
 it("возвращает NaN при попытке вычислить корень из отрицательного числа", function () {
 expect(Math.sqrt(-9)).toBe(NaN);
 });
});
```
Если не обращать внимание на некоторую нечитаемость текста из-за смеси русского и английского, то в
общем код теста действительно напоминает список требований к функции. Мы описываем конкретные
тестовые случаи с помощью конструкций `expect(...).toBe(...)` где указываем пример выполняемого кода
и ожидаемый результат.
Вот результат выполнения этих тестов в браузере, где Jasmine выводит список пройденных проверок: 
![Результат запуска теста Jasmine в браузере](http://i.imgur.com/TUzORGe.png)
Jasmine расширяемый и вы можете дописывать свои проверяльщики (matchers) и свой код для вывода
результатов в удобном вам виде.
10.02.2022, 20:59 https://gist.githubusercontent.com/codedokode/a455bde7d0748c0a351a/raw/af3c559f823c37ec51924cb90942eb98b2edf2e2/%…
https://gist.githubusercontent.com/codedokode/a455bde7d0748c0a351a/raw/af3c559f823c37ec51924cb90942eb98b2edf2e2/%25D0%25A2%25D… 10/12
## Дополнительные инструменты
### Skipfish 
[Skipfish](http://code.google.com/p/skipfish/) (англ.) — инструмент от Google, который может
использоваться для поиска ошибок на сайте и заодно для нагрузочного тестирования. Он обходит все
страницы, начиная со стартовой и перемещаясь по ссылкам, и позволяет обнаруживать битые ссылки (в том
числе на картинки, CSS и JS файлы). Также, он умеет отправлять запросы со случайно сгенерированными
данными и пытается искать явные XSS/SQL уязвимости. Он работает очень быстро (если конечно сайт может
отвечать быстро). 
Skipfish — это не совсем средство автоматического тестирования, так как результаты работы выдаются в
виде html-отчета, но он может быть полезен например для поиска ошибок на существующем сайте.
Skipfish генерирует большую нагрузку на сайт и шлет очень много запросов, потому применяй его только
на своих сайтах.
### PhantomJS
[PhantomJS](http://phantomjs.org/) — это браузерный движок (используется Webkit — тот же, что
используется в Safari, Opera, Яндекс-браузере и старых версиях Хрома), которым можно управлять с
помощью скриптов на яваскрипте. Это headless браузер, то есть он не выводит никаких окон (и вообще не
требует наличия видеокарты и дисплея), а работает как приложение командной строки. Он
кроссплатформенный и его можно запускать, например, автоматически на линукс сервере. Он умеет
переходить по страницам, загружать CSS/JS (при желании и картинки), делать скриншоты, выполнять
произвольный JS код в контексте страницы.
Также, для PhantomJS есть плагин ghostdriver (WebDriver), который позволяет подсоединиться к
программе извне и управлять ей. Он использует протокол Selenium, и с его помощью PhantomJS можно
управлять из codeception.
Тесты по идее можно писать на яваскрипте, скармливая их напрямую PhantomJS, но удобнее использовать
какую-нибудь библиотеку работающую поверх него, например, [Casper.js](http://casperjs.org/) (это если
вы готов писать тесты на явскрипте, если на PHP, то стоит использовать codeception + PhantomJS через
WebDriver).
Для повышения скорости работы теста стоит отключить загрузку картинок, если они не требуются для
теста.
Статьи по использованию PhantomJS с codeception наверно нетрудно нагуглить.
### Selenium
[Selenium](http://www.seleniumhq.org/) — это проект, предоставляющий драйвера для разных браузеров,
которые встраиваются в них и позволяют управлять ими. Также, Selenium содержит сервер, который
позволяет управлять большим числом разных браузеров ии распределять задания между ними.
Selenium сервер написан на Яве, потому она понадобится чтобы его запустить. Поддерживаются браузеры
Firefox, IE (6-11), Safari на OS X, Opera 12 (старая Опера), Chrome.
Selenium дает наиболее полноценное тестирование, так как вы можете запускать код в конкретной версии
браузера (например, IE) под конкретной ОС. Но его настройка сложнее чем других инструментов, и он
требует больше ресурсов. Когда выполняется тест, браузер должен быть запущен и вы не можете
пользоваться компьютером, так как один лишний клик может сорвать выполнение теста. По этой причине
для тестов обычно поднимают сеть вирутальных машин, в которых тесты и выполняются. 
Так как настроить окружение для запуска тестов сложно, есть коммерческие сервисы (например saucelabs)
которые за плату выполняют selenium-тесты на нужных браузерах и возвращают результат. Они
предоставляют API с помощью которого тесты можно запускать автоматически и умеют отслеживать
изменения в репозитории, тестируя код при каждом новом коммите.
Тесты в браузере содержат подвохи: например, когда вы программно нажимаете кнопку, браузеру нужно
время, чтобы выполнить привязанный к ней яваскрипт, обработать изменения в DOM, перерисовать экран.
Если ваш скрипт не будет дожидаться этого, а попробует сразу после нажатия кнопки проверить изменения
10.02.2022, 20:59 https://gist.githubusercontent.com/codedokode/a455bde7d0748c0a351a/raw/af3c559f823c37ec51924cb90942eb98b2edf2e2/%…
https://gist.githubusercontent.com/codedokode/a455bde7d0748c0a351a/raw/af3c559f823c37ec51924cb90942eb98b2edf2e2/%25D0%25A2%25D0… 11/12
на экране, он может их не увидеть. В некоторых статьях вы можете увидеть совет вроде «делать паузу N
мс после каждого шага», но это плохие советы. Во-первых, нет гарантий, что действие выполнится за эти
N мс, во-вторых, это сильно тормозит тесты. Лучше, как советует Яндекс, в таких случаях периодически
проверять появление определенного элемента на странице.
Также, не так просто проверить, что элемент видим. Ведь в CSS много свойств (`opacity`,
`visisbility`, `display`), которыми можно его скрыть, плюс он может быть помещен за пределами экрана.
Тесты в браузере могут быть хрупкими. У браузера может выскочить окно обновления, может произойти
ошибка при загрузке какого-то внешнего ресурса, в общем, сложностей тут много. А кто говорил, что
будет легко? 
Также, Selenium содержит плагин к фаерфоксу (Selenium IDE), который позволяет записывать действия
пользователя и генерировать из них тест (то есть повторять эти действия позже), но он, как я понимаю,
довольно слабый и генерирует тяжелочитаемый код на своем странном языке. Гораздо лучше управлять
Selenium из codeception и писать тесты на PHP.
Статьи: 
- отличная статья от Яндекса http://habrahabr.ru/company/yandex/blog/173769/
- http://habrahabr.ru/post/152653/
### Travis CI
Чтобы не запускать тесты каждый раз руками, используют CI Server вроде Teamcity, Jenkins или Hudson
(статья от Яндекса: http://habrahabr.ru/company/yandex/blog/237017/ ). Но эти системы надо
устанавливать и настраивать, в то время как Travis это сервис, который сам будет подсоединяться к
твоему гитхаб репозиторию, брать оттуда изменения и прогонять тесты. Для open source проектов на
github Travis CI бесплатен.
## Ссылки
Статья с теорией и определениями разных терминов (что такое тест-кейс, какие бывают уровни
тестирования, серьезность дефекта, виды тестирования ит.д.): [Тестирование. Фундаментальная теория]
(https://habr.com/post/279535/)
На хабре хорошие статьи про тестирование в блогах Яндекса и Баду: 
- http://habrahabr.ru/company/badoo/blog/190572/
- http://habrahabr.ru/company/badoo/blog/216255/
- http://habrahabr.ru/company/yandex/blog/173769/
- http://habrahabr.ru/company/yandex/blog/193918/
- http://habrahabr.ru/company/yandex/blog/202020/
- http://habrahabr.ru/company/yandex/blog/200968/
Вот примеры разных open source проектов c тестами (кстати, многие из них используют travis CI): 
- PHP фреймворк Slim https://github.com/codeguy/Slim
- библиотека-HTTP клиент Guzzle: https://github.com/guzzle/guzzle
- JS библиотека jQuery https://github.com/jquery/jquery (используется фреймворк QUnit вроде бы)
## Задачи
Разумеется, чтобы закрепить знания, а также изучить практические особенности тестирования, нам надо
решить задачки и что-нибудь потестировать. Предлагаю тестировать приложение-файлообменник, у меня их
аж несколько: 
- https://github.com/sqghub/uppu.ru/ (на Slim)
- https://github.com/Verpul/uppu.ru (на F3 framework)
- https://github.com/dKab/download.me (на Slim, но почему-то не использует композер. Это придется
исправить)
вы форкаете тот, который вам больше нравится (или меньше не нравится), и мы пишем под него юнит-тесты
на phpUnit и интерфейсные тесты на codeception. 
10.02.2022, 20:59 https://gist.githubusercontent.com/codedokode/a455bde7d0748c0a351a/raw/af3c559f823c37ec51924cb90942eb98b2edf2e2/%…
https://gist.githubusercontent.com/codedokode/a455bde7d0748c0a351a/raw/af3c559f823c37ec51924cb90942eb98b2edf2e2/%25D0%25A2%25D… 12/12
Если вам не нравится файлообменник, можно потестировать что-то еще (если есть идеи небольшого
приложения на PHP, требующего тестов — напишите).
Прежде чем писать тесты, надо составить план тестирования (что мы тестируем и как). Мы сначала
определяем, какие возможности предоставляет приложение, а потом для каждой пишем несколько тест
кейсов. Не забывайте, что надо тестировать как позитивные, так и негативные сценарии. Вот примерный
план, 1 пункт = 1 тест. 

